#!/bin/bash
# git-commit-plan: Execute a commit plan from JSON
#
# Separates semantic analysis (AI agent) from mechanical execution (this script).
# The AI agent outputs a JSON plan describing what goes in each commit.
# This script executes the plan: staging, committing, and cleanup.
#
# Usage: git-commit-plan <plan.json> [plan2.json ...]
#        git-commit-plan <directory>
#        git-commit-plan --stdin < plan.json
#        echo '{"commits":[...]}' | git-commit-plan --stdin
#
# Plan format:
# {
#   "commits": [
#     {
#       "message": "type(Scope): what (why)",
#       "files": [
#         {"path": "file.ext"},                              // full: git add
#         {"path": "file.ext", "hunks": [0, 2]},             // hunk-select
#         {"path": "file.ext", "intermediate": "/tmp/v1.ext"} // hash-object
#       ]
#     }
#   ]
# }
#
# Schema: schemas/commit-plan.schema.json
#
# File strategies (auto-detected from fields):
#   - full:        No hunks or intermediate → git add <file>
#   - hunk-select: hunks array → extract specific hunks from -U0 diff
#   - hash-object: intermediate path → git hash-object + update-index
#
# Dependencies: jq, git
# Exit codes: 0 = success, 1 = error

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Global counters for multi-plan accumulation
_committed=0
_failed=0
_total_commits=0

# --- Helpers ---

die() {
    echo -e "${RED}ERROR:${NC} $1" >&2
    exit 1
}

info() {
    echo -e "${BLUE}→${NC} $1"
}

success() {
    echo -e "${GREEN}✔${NC} $1"
}

warn() {
    echo -e "${YELLOW}⚠${NC} $1"
}

check_dependencies() {
    command -v jq >/dev/null 2>&1 || die "jq is required but not installed"
    command -v git >/dev/null 2>&1 || die "git is required but not installed"
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "not inside a git repository"
}

# --- Plan Validation ---

# Validate a JSON commit plan structure
# Args: $1 = JSON string
# Returns: 0 = valid, 1 = invalid (errors on stderr)
# Warnings go to stderr but do not affect return code
validate_plan() {
    local plan_json="$1"

    # Check valid JSON
    if ! echo "$plan_json" | jq empty 2>/dev/null; then
        echo -e "${RED}ERROR:${NC} invalid JSON in plan" >&2
        return 1
    fi

    # Structural validation via single jq call
    local errors
    errors=$(echo "$plan_json" | jq -r '
        def validate:
            # commits must be a non-empty array
            (if (.commits | type) != "array" then ["missing or invalid commits array"] else [] end) +
            (if (.commits | type) == "array" and (.commits | length) == 0 then ["no commits in plan"] else [] end) +

            # validate each commit
            (if (.commits | type) == "array" then
                [.commits | to_entries[] | .key as $i | .value |
                    # message must be a non-empty string
                    (if (.message | type) != "string" or (.message | length) == 0
                     then "commit[\($i)]: missing or empty message" else empty end),

                    # files must be a non-empty array
                    (if (.files | type) != "array" or (.files | length) == 0
                     then "commit[\($i)]: missing or empty files array" else empty end),

                    # validate each file entry
                    (if (.files | type) == "array" then
                        .files | to_entries[] | .key as $j | .value |
                            # path must be a non-empty string
                            (if (.path | type) != "string" or (.path | length) == 0
                             then "commit[\($i)].files[\($j)]: missing or empty path" else empty end),

                            # hunks and intermediate are mutually exclusive
                            (if .hunks != null and .intermediate != null
                             then "commit[\($i)].files[\($j)]: cannot have both hunks and intermediate" else empty end),

                            # hunks must be non-negative integers
                            (if .hunks != null then
                                .hunks | to_entries[] | .key as $k | .value |
                                    if (type != "number") or (. != (. | floor)) or (. < 0)
                                    then "commit[\($i)].files[\($j)].hunks[\($k)]: must be a non-negative integer"
                                    else empty end
                             else empty end)
                     else empty end)
                ]
             else [] end);

        validate | .[]
    ' 2>/dev/null)

    if [ -n "$errors" ]; then
        while IFS= read -r err; do
            echo -e "${RED}ERROR:${NC} $err" >&2
        done <<< "$errors"
        return 1
    fi

    # Commit message format warning (non-fatal)
    local warnings
    warnings=$(echo "$plan_json" | jq -r '
        [.commits | to_entries[] | .key as $i | .value |
            if (.message | test("(feat|fix|wip|refactor|test|docs|chore)\\(") | not)
            then "commit[\($i)]: message does not match format type(Scope): what (why)"
            else empty end
        ] | .[]
    ' 2>/dev/null) || true

    if [ -n "$warnings" ]; then
        while IFS= read -r w; do
            warn "$w" >&2
        done <<< "$warnings"
    fi

    return 0
}

# --- Hunk Extraction ---

# Compute net line change from a @@ header line
# @@ -old_start[,old_count] +new_start[,new_count] @@
# Returns: new_count - old_count (positive = lines added, negative = lines removed)
compute_hunk_net_change() {
    local header="$1"
    local old_count=1
    local new_count=1

    if [[ "$header" =~ ^@@\ -([0-9]+)(,([0-9]+))?\ \+([0-9]+)(,([0-9]+))?\ @@ ]]; then
        old_count="${BASH_REMATCH[3]:-1}"
        new_count="${BASH_REMATCH[6]:-1}"
    fi

    echo $((new_count - old_count))
}

# Adjust +new_start in a @@ header by subtracting a delta
# Used when skipped hunks shift line numbers in the new file
adjust_hunk_header() {
    local header="$1"
    local delta="$2"

    if [[ "$header" =~ ^(@@\ -[0-9]+(,[0-9]+)?\ \+)([0-9]+)(.*) ]]; then
        local prefix="${BASH_REMATCH[1]}"
        local new_start="${BASH_REMATCH[3]}"
        local suffix="${BASH_REMATCH[4]}"
        local adjusted=$((new_start - delta))
        echo "${prefix}${adjusted}${suffix}"
    else
        echo "$header"
    fi
}

# Extract specific hunks from a -U0 diff and create a partial patch
# When non-contiguous hunks are selected, adjusts @@ line numbers to account
# for skipped hunks whose line changes are not present in the partial patch.
# Args: $1 = file path, $2 = comma-separated hunk indices (e.g., "0,2")
# Output: patch content on stdout
extract_hunks() {
    local file="$1"
    local hunk_indices="$2"
    local diff_output

    diff_output=$(git diff --no-ext-diff -U0 "$file" 2>/dev/null)
    if [ -z "$diff_output" ]; then
        echo "ERROR: no diff found for '$file'" >&2
        return 1
    fi

    # Extract header (first 4 lines: diff --git, index, ---, +++)
    local header
    header=$(echo "$diff_output" | head -4)

    # Extract selected @@ blocks with their content.
    # Track cumulative line-count delta from skipped hunks so that
    # +new_start in later selected hunks can be adjusted.
    local current_hunk=-1
    local in_selected=0
    local skipped_delta=0
    local result="$header"

    while IFS= read -r line; do
        if [[ "$line" =~ ^@@ ]]; then
            current_hunk=$((current_hunk + 1))
            in_selected=0
            # Check if this hunk index is in our selection
            IFS=',' read -ra indices <<< "$hunk_indices"
            for idx in "${indices[@]}"; do
                if [ "$idx" -eq "$current_hunk" ]; then
                    in_selected=1
                    break
                fi
            done

            if [ "$in_selected" -eq 1 ]; then
                # Adjust +new_start if preceding hunks were skipped
                if [ "$skipped_delta" -ne 0 ]; then
                    line=$(adjust_hunk_header "$line" "$skipped_delta")
                fi
            else
                # Skipped hunk: accumulate its net line change
                local net_change
                net_change=$(compute_hunk_net_change "$line")
                skipped_delta=$((skipped_delta + net_change))
            fi
        fi
        if [ "$in_selected" -eq 1 ]; then
            result="$result"$'\n'"$line"
        fi
    done <<< "$(echo "$diff_output" | tail -n +5)"

    echo "$result"
}

# --- Stage File by Strategy ---

# Stage a file using the appropriate strategy
# Args: $1 = JSON object for this file entry
stage_file() {
    local file_json="$1"
    local file_path
    local strategy

    file_path=$(echo "$file_json" | jq -r '.path')

    # Auto-detect strategy from fields
    if echo "$file_json" | jq -e '.intermediate' >/dev/null 2>&1; then
        strategy="hash-object"
    elif echo "$file_json" | jq -e '.hunks' >/dev/null 2>&1; then
        strategy="hunk-select"
    else
        strategy="full"
    fi

    case "$strategy" in
        full)
            git add "$file_path"
            ;;

        hunk-select)
            local hunk_indices
            hunk_indices=$(echo "$file_json" | jq -r '.hunks | join(",")')
            local patch
            if ! patch=$(extract_hunks "$file_path" "$hunk_indices"); then
                echo "ERROR: failed to extract hunks for '$file_path'" >&2
                return 1
            fi

            # Check if any hunks were actually selected (patch has more than just header)
            local patch_lines
            patch_lines=$(echo "$patch" | wc -l | tr -d ' ')
            if [ "$patch_lines" -le 4 ]; then
                echo "ERROR: no matching hunks found for '$file_path' (indices: $hunk_indices)" >&2
                return 1
            fi

            local tmp_patch
            tmp_patch=$(mktemp /tmp/agentic-patch-XXXXXX)
            echo "$patch" > "$tmp_patch"

            if ! git apply --check --cached --unidiff-zero "$tmp_patch" 2>/dev/null; then
                rm -f "$tmp_patch"
                echo "ERROR: hunk-select patch does not apply cleanly for '$file_path'" >&2
                return 1
            fi

            git apply --cached --unidiff-zero "$tmp_patch"
            rm -f "$tmp_patch"
            ;;

        hash-object)
            local intermediate
            intermediate=$(echo "$file_json" | jq -r '.intermediate')

            if [ ! -f "$intermediate" ]; then
                echo "ERROR: intermediate file not found: '$intermediate'" >&2
                return 1
            fi

            local blob
            blob=$(git hash-object -w "$intermediate")
            git update-index --cacheinfo 100644,"$blob","$file_path"
            ;;
    esac
}

# --- Process Plan ---

# Re-index hunk indices for a file that has had previous hunks committed.
# After committing hunks [0,2,4], the remaining hunks shift down.
# Formula: new_index = original_index - count(committed_hunks < original_index)
# Args: $1 = file JSON with hunks array, $2 = space-separated sorted committed hunk indices
# Output: updated file JSON with re-indexed hunks on stdout
reindex_hunks() {
    local file_json="$1"
    local committed_str="$2"

    # Convert committed hunks to array
    local -a committed=()
    read -ra committed <<< "$committed_str"

    # Get original hunk indices
    local original_hunks
    original_hunks=$(echo "$file_json" | jq -r '.hunks | join(" ")')

    local -a new_hunks=()
    for orig_idx in $original_hunks; do
        local offset=0
        for c in "${committed[@]}"; do
            if [ "$c" -lt "$orig_idx" ]; then
                offset=$((offset + 1))
            fi
        done
        new_hunks+=($((orig_idx - offset)))
    done

    # Rebuild file JSON with new hunk indices
    local hunks_json
    hunks_json=$(printf '%s\n' "${new_hunks[@]}" | jq -s '.')
    echo "$file_json" | jq --argjson h "$hunks_json" '.hunks = $h'
}

# Execute all commits in a validated plan
# Args: $1 = JSON string (already validated)
# Updates global _committed, _failed, _total_commits counters
process_plan() {
    local plan_json="$1"

    local commit_count
    commit_count=$(echo "$plan_json" | jq '.commits | length')
    _total_commits=$((_total_commits + commit_count))

    # Track committed hunk indices per file path for re-indexing.
    # Uses parallel arrays since bash 3 lacks associative arrays.
    # _chf_paths[i] = file path, _chf_hunks[i] = space-separated sorted hunk indices
    local -a _chf_paths=()
    local -a _chf_hunks=()

    for i in $(seq 0 $((commit_count - 1))); do
        local commit_json
        commit_json=$(echo "$plan_json" | jq ".commits[$i]")

        local message
        message=$(echo "$commit_json" | jq -r '.message')

        local file_count
        file_count=$(echo "$commit_json" | jq '.files | length')

        info "Commit $((i + 1))/$commit_count: $message"

        # Stage each file
        local stage_failed=0
        for j in $(seq 0 $((file_count - 1))); do
            local file_json
            file_json=$(echo "$commit_json" | jq ".files[$j]")
            local file_path
            file_path=$(echo "$file_json" | jq -r '.path')

            # Re-index hunks if this file had previous hunk-select commits
            if echo "$file_json" | jq -e '.hunks' >/dev/null 2>&1; then
                local prev_hunks=""
                local chf_len=${#_chf_paths[@]:-0}
                if [ "$chf_len" -gt 0 ]; then
                    for k in $(seq 0 $((chf_len - 1))); do
                        if [ "${_chf_paths[$k]}" = "$file_path" ]; then
                            prev_hunks="${_chf_hunks[$k]}"
                            break
                        fi
                    done
                fi

                if [ -n "$prev_hunks" ]; then
                    file_json=$(reindex_hunks "$file_json" "$prev_hunks")
                fi
            fi

            if ! stage_file "$file_json" 2>/dev/null; then
                warn "  Failed to stage: $file_path"
                stage_failed=1
                break
            fi
        done

        if [ "$stage_failed" -eq 1 ]; then
            warn "  Skipping commit (staging failed)"
            git reset HEAD -- . >/dev/null 2>&1 || true
            _failed=$((_failed + 1))
            continue
        fi

        # Verify something is staged
        if git diff --cached --quiet 2>/dev/null; then
            warn "  Nothing staged, skipping"
            continue
        fi

        # Commit
        if git commit -m "$message" >/dev/null 2>&1; then
            # Verify one file per commit
            local files_changed
            files_changed=$(git show --stat HEAD --format="" | grep '|' | wc -l | tr -d ' ')
            if [ "$files_changed" -gt 1 ]; then
                warn "  Committed but $files_changed files changed (expected 1)"
            fi
            success "  Committed ($files_changed file)"
            _committed=$((_committed + 1))

            # Record committed hunks for re-indexing future commits
            for j in $(seq 0 $((file_count - 1))); do
                local rec_json
                rec_json=$(echo "$commit_json" | jq ".files[$j]")
                if echo "$rec_json" | jq -e '.hunks' >/dev/null 2>&1; then
                    local rec_path
                    rec_path=$(echo "$rec_json" | jq -r '.path')
                    local rec_hunks
                    rec_hunks=$(echo "$rec_json" | jq -r '.hunks | sort | join(" ")')

                    # Find existing entry or create new
                    local found=0
                    local chf_rec_len=${#_chf_paths[@]:-0}
                    if [ "$chf_rec_len" -gt 0 ]; then
                        for k in $(seq 0 $((chf_rec_len - 1))); do
                            if [ "${_chf_paths[$k]}" = "$rec_path" ]; then
                                _chf_hunks[$k]="${_chf_hunks[$k]} $rec_hunks"
                                found=1
                                break
                            fi
                        done
                    fi
                    if [ "$found" -eq 0 ]; then
                        _chf_paths+=("$rec_path")
                        _chf_hunks+=("$rec_hunks")
                    fi
                fi
            done
        else
            warn "  Commit failed"
            git reset HEAD -- . >/dev/null 2>&1 || true
            _failed=$((_failed + 1))
        fi
    done
}

# --- Main ---

main() {
    check_dependencies

    # Collect plan sources
    local plan_files=()
    local from_stdin=0

    if [ "${1:-}" = "--stdin" ]; then
        from_stdin=1
    elif [ $# -eq 0 ]; then
        die "usage: git-commit-plan <plan.json|dir> [...] | git-commit-plan --stdin"
    else
        # Process all arguments
        for arg in "$@"; do
            if [ -d "$arg" ]; then
                # Directory: collect all .json files sorted alphabetically
                local dir_files
                dir_files=()
                while IFS= read -r -d '' f; do
                    dir_files+=("$f")
                done < <(find "$arg" -maxdepth 1 -name '*.json' -print0 | sort -z)

                if [ ${#dir_files[@]} -eq 0 ]; then
                    die "no JSON files found in directory: '$arg'"
                fi

                plan_files+=("${dir_files[@]}")
            elif [ -f "$arg" ]; then
                plan_files+=("$arg")
            else
                die "plan file not found: '$arg'"
            fi
        done
    fi

    # Process stdin mode (single plan)
    if [ "$from_stdin" -eq 1 ]; then
        local plan_json
        plan_json=$(cat)

        if ! validate_plan "$plan_json"; then
            exit 1
        fi

        local commit_count
        commit_count=$(echo "$plan_json" | jq '.commits | length')
        info "Executing commit plan ($commit_count commits)"
        echo ""

        process_plan "$plan_json"

        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        success "Done: $_committed committed, $_failed failed"

        echo ""
        git log --oneline -"$_total_commits" 2>/dev/null

        if ! git diff --quiet 2>/dev/null; then
            echo ""
            warn "Remaining unstaged changes:"
            git diff --stat 2>/dev/null
        fi

        [ "$_failed" -eq 0 ] && return 0 || return 1
    fi

    # Process file(s) mode
    local plan_count=${#plan_files[@]}
    local any_validation_failed=0

    for plan_file in "${plan_files[@]}"; do
        local plan_json
        plan_json=$(cat "$plan_file")

        if ! validate_plan "$plan_json"; then
            warn "Skipping invalid plan: $plan_file"
            any_validation_failed=1
            continue
        fi

        local commit_count
        commit_count=$(echo "$plan_json" | jq '.commits | length')

        if [ "$plan_count" -gt 1 ]; then
            echo ""
            info "Plan: $(basename "$plan_file") ($commit_count commits)"
        else
            info "Executing commit plan ($commit_count commits)"
        fi
        echo ""

        process_plan "$plan_json"
    done

    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    success "Done: $_committed committed, $_failed failed"

    # Show recent commits
    if [ "$_total_commits" -gt 0 ]; then
        echo ""
        git log --oneline -"$_total_commits" 2>/dev/null
    fi

    # Check for remaining changes
    if ! git diff --quiet 2>/dev/null; then
        echo ""
        warn "Remaining unstaged changes:"
        git diff --stat 2>/dev/null
    fi

    [ "$_failed" -eq 0 ] && [ "$any_validation_failed" -eq 0 ] && return 0 || return 1
}

main "$@"
