#!/bin/bash
# git-commit-plan: Execute a commit plan from JSON
#
# Separates semantic analysis (AI agent) from mechanical execution (this script).
# The AI agent outputs a JSON plan describing what goes in each commit.
# This script executes the plan: staging, committing, and cleanup.
#
# Usage: git-commit-plan <plan.json>
#        git-commit-plan --stdin < plan.json
#        echo '{"commits":[...]}' | git-commit-plan --stdin
#
# Plan format:
# {
#   "commits": [
#     {
#       "message": "type(Scope): what (why)",
#       "files": [
#         {"path": "file.ext"},                              // full: git add
#         {"path": "file.ext", "hunks": [0, 2]},             // hunk-select
#         {"path": "file.ext", "intermediate": "/tmp/v1.ext"} // hash-object
#       ]
#     }
#   ]
# }
#
# File strategies (auto-detected from fields):
#   - full:        No hunks or intermediate → git add <file>
#   - hunk-select: hunks array → extract specific hunks from -U0 diff
#   - hash-object: intermediate path → git hash-object + update-index
#
# Dependencies: jq, git
# Exit codes: 0 = success, 1 = error

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# --- Helpers ---

die() {
    echo -e "${RED}ERROR:${NC} $1" >&2
    exit 1
}

info() {
    echo -e "${BLUE}→${NC} $1"
}

success() {
    echo -e "${GREEN}✔${NC} $1"
}

warn() {
    echo -e "${YELLOW}⚠${NC} $1"
}

check_dependencies() {
    command -v jq >/dev/null 2>&1 || die "jq is required but not installed"
    command -v git >/dev/null 2>&1 || die "git is required but not installed"
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "not inside a git repository"
}

# --- Hunk Extraction ---

# Extract specific hunks from a -U0 diff and create a partial patch
# Args: $1 = file path, $2 = comma-separated hunk indices (e.g., "0,2")
# Output: patch content on stdout
extract_hunks() {
    local file="$1"
    local hunk_indices="$2"
    local diff_output

    diff_output=$(git diff --no-ext-diff -U0 "$file" 2>/dev/null)
    if [ -z "$diff_output" ]; then
        echo "ERROR: no diff found for '$file'" >&2
        return 1
    fi

    # Extract header (first 4 lines: diff --git, index, ---, +++)
    local header
    header=$(echo "$diff_output" | head -4)

    # Extract all @@ blocks with their content
    # Each hunk starts with @@ and continues until the next @@ or end
    local current_hunk=-1
    local in_selected=0
    local result="$header"

    while IFS= read -r line; do
        if [[ "$line" =~ ^@@ ]]; then
            current_hunk=$((current_hunk + 1))
            in_selected=0
            # Check if this hunk index is in our selection
            IFS=',' read -ra indices <<< "$hunk_indices"
            for idx in "${indices[@]}"; do
                if [ "$idx" -eq "$current_hunk" ]; then
                    in_selected=1
                    break
                fi
            done
        fi
        if [ "$in_selected" -eq 1 ]; then
            result="$result"$'\n'"$line"
        fi
    done <<< "$(echo "$diff_output" | tail -n +5)"

    echo "$result"
}

# --- Stage File by Strategy ---

# Stage a file using the appropriate strategy
# Args: $1 = JSON object for this file entry
stage_file() {
    local file_json="$1"
    local file_path
    local strategy

    file_path=$(echo "$file_json" | jq -r '.path')

    # Auto-detect strategy from fields
    if echo "$file_json" | jq -e '.intermediate' >/dev/null 2>&1; then
        strategy="hash-object"
    elif echo "$file_json" | jq -e '.hunks' >/dev/null 2>&1; then
        strategy="hunk-select"
    else
        strategy="full"
    fi

    case "$strategy" in
        full)
            git add "$file_path"
            ;;

        hunk-select)
            local hunk_indices
            hunk_indices=$(echo "$file_json" | jq -r '.hunks | join(",")')
            local patch
            if ! patch=$(extract_hunks "$file_path" "$hunk_indices"); then
                echo "ERROR: failed to extract hunks for '$file_path'" >&2
                return 1
            fi

            # Check if any hunks were actually selected (patch has more than just header)
            local patch_lines
            patch_lines=$(echo "$patch" | wc -l | tr -d ' ')
            if [ "$patch_lines" -le 4 ]; then
                echo "ERROR: no matching hunks found for '$file_path' (indices: $hunk_indices)" >&2
                return 1
            fi

            local tmp_patch
            tmp_patch=$(mktemp /tmp/agentic-patch-XXXXXX)
            echo "$patch" > "$tmp_patch"

            if ! git apply --check --cached --unidiff-zero "$tmp_patch" 2>/dev/null; then
                rm -f "$tmp_patch"
                echo "ERROR: hunk-select patch does not apply cleanly for '$file_path'" >&2
                return 1
            fi

            git apply --cached --unidiff-zero "$tmp_patch"
            rm -f "$tmp_patch"
            ;;

        hash-object)
            local intermediate
            intermediate=$(echo "$file_json" | jq -r '.intermediate')

            if [ ! -f "$intermediate" ]; then
                echo "ERROR: intermediate file not found: '$intermediate'" >&2
                return 1
            fi

            local blob
            blob=$(git hash-object -w "$intermediate")
            git update-index --cacheinfo 100644,"$blob","$file_path"
            ;;
    esac
}

# --- Main ---

main() {
    check_dependencies

    # Parse arguments
    local plan_json
    if [ "${1:-}" = "--stdin" ]; then
        plan_json=$(cat)
    elif [ -n "${1:-}" ]; then
        if [ ! -f "$1" ]; then
            die "plan file not found: '$1'"
        fi
        plan_json=$(cat "$1")
    else
        die "usage: git-commit-plan <plan.json> | git-commit-plan --stdin"
    fi

    # Validate JSON
    if ! echo "$plan_json" | jq empty 2>/dev/null; then
        die "invalid JSON in plan"
    fi

    local commit_count
    commit_count=$(echo "$plan_json" | jq '.commits | length')

    if [ "$commit_count" -eq 0 ]; then
        die "no commits in plan"
    fi

    info "Executing commit plan ($commit_count commits)"
    echo ""

    local committed=0
    local failed=0

    for i in $(seq 0 $((commit_count - 1))); do
        local commit_json
        commit_json=$(echo "$plan_json" | jq ".commits[$i]")

        local message
        message=$(echo "$commit_json" | jq -r '.message')

        local file_count
        file_count=$(echo "$commit_json" | jq '.files | length')

        info "Commit $((i + 1))/$commit_count: $message"

        # Stage each file
        local stage_failed=0
        for j in $(seq 0 $((file_count - 1))); do
            local file_json
            file_json=$(echo "$commit_json" | jq ".files[$j]")
            local file_path
            file_path=$(echo "$file_json" | jq -r '.path')

            if ! stage_file "$file_json" 2>/dev/null; then
                warn "  Failed to stage: $file_path"
                stage_failed=1
                break
            fi
        done

        if [ "$stage_failed" -eq 1 ]; then
            warn "  Skipping commit (staging failed)"
            git reset HEAD -- . >/dev/null 2>&1 || true
            failed=$((failed + 1))
            continue
        fi

        # Verify something is staged
        if git diff --cached --quiet 2>/dev/null; then
            warn "  Nothing staged, skipping"
            continue
        fi

        # Commit
        if git commit -m "$message" >/dev/null 2>&1; then
            # Verify one file per commit
            local files_changed
            files_changed=$(git show --stat HEAD --format="" | grep '|' | wc -l | tr -d ' ')
            if [ "$files_changed" -gt 1 ]; then
                warn "  Committed but $files_changed files changed (expected 1)"
            fi
            success "  Committed ($files_changed file)"
            committed=$((committed + 1))
        else
            warn "  Commit failed"
            git reset HEAD -- . >/dev/null 2>&1 || true
            failed=$((failed + 1))
        fi
    done

    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    success "Done: $committed committed, $failed failed"

    # Show result
    echo ""
    git log --oneline -"$commit_count" 2>/dev/null

    # Check for remaining changes
    if ! git diff --quiet 2>/dev/null; then
        echo ""
        warn "Remaining unstaged changes:"
        git diff --stat 2>/dev/null
    fi

    [ "$failed" -eq 0 ] && return 0 || return 1
}

main "$@"
